"""
Many tests here use caplog (CAPtured LOGged messages)
pytest caplog is a built-in fixture provided by the pytest
testing framework in Python.
It is used for capturing and inspecting log messages during test execution.
The caplog fixture allows you to access log records generated by your code
under test, making it easier to assert and analyze log output in your tests.

When you use the caplog fixture in your test function or test method,
pytest captures all log messages emitted by the code being tested.
You can then access these log records through the caplog.records attribute.
"""
import logging

# from ansi2html import strip_ansi
import re

# from logging import DEBUG, INFO, WARN, LogRecord
from logging import INFO
from typing import List
from unittest import mock
from unittest.mock import call, patch

import pytest

# from pytest_bdd.parser import Feature, Scenario, ScenarioTemplate, Step
from tests.common.pytest_bdd_logger_interface import (
    TEST_CONTEXT,
    COL_CONTEXT,
    COL_MSG,
    COL_RESET,
    # ret_keys,
    # _log_dict_now,  # TODO Make test
    _log_func_name,
    _ret_dict_info,
    _ret_func_name,
)
from tests.common.log_glue_incl import (
    log_headline,  # TODO Move to interface
    ret_before_or_after,  # TODO Move to interface
    ret_keys,  # TODO Move to interface
    xret_sorted,  # TODO Move to interface
)


def _the_caller(prev: int = 0) -> str:
    return _ret_func_name(prev)


def _func1(prev: int = 1) -> str:
    return _the_caller(prev)


def _func2(prev: int = 2) -> str:
    return _func1(prev)


def _func3(prev: int = 3) -> str:
    # _func3: _func2 -> _func1 -> _the_caller
    return _func2(prev)


@pytest.mark.okz
def test_just_show_test_context() -> None:
    logging.info('==> test_just_show_test_context')
    logging.info('TEST_CONTEXT: ')
    logging.info(TEST_CONTEXT)
    logging.info('<== test_just_show_test_context')


@pytest.mark.ok
def test_ret_func_name() -> None:

    # logging.info('==> test__ret_func_name')

    assert _ret_func_name() == 'test_ret_func_name'

    # The different _func have a default "prev" param
    # that will be passed on to _the_caller and should return themself
    # _the_caller is the only function calling _ret_func_name function.

    assert _the_caller() == '_the_caller'   # _the_caller of _ret_func_name
    assert _func1() == '_func1'             # will only call _the_caller
    assert _func2() == '_func2'             # will only call _func1
    assert _func3() == '_func3'             # will only call _func2
    assert _func3(3) == '_func3'            # will only call _func2(prev=3)
    assert _func3(2) == '_func2'            # will only call _func2(prev=2)
    assert _func3(1) == '_func1'            # will only call _func2(prev=1)
    assert _func3(0) == '_the_caller'       # will only call _func2(prev=0)

    # logging.info('<== test__ret_func_name')


@pytest.mark.skip
def test__ret_func_name2() -> None:
    this_func = '?'
    print(__file__)
    with mock.patch('tests.common.log_glue_incl.logging') as mock_logger:
        this_func = _ret_func_name()
        mock_logger.debug.assert_called_once_with('>> _ret_func_name')

    assert this_func == 'test__ret_func_name'


@pytest.mark.okz
def test_ret_sorted() -> None:
    some_dict = {'c': 'C', 'a': 'A', 'b': 'B'}
    correct_dict = {'a': 'A', 'b': 'B', 'c': 'C'}
    some_keys = ret_keys(some_dict)
    print(some_dict)
    print(some_keys)
    sorted_dict = xret_sorted(some_dict)
    sorted_keys = ret_keys(sorted_dict)
    print(some_dict)
    print(some_keys)
    print(sorted_dict)
    print(sorted_keys)
    assert sorted_dict == correct_dict, 'The sort is NOT right'
    assert ret_keys(sorted_dict) == ret_keys(correct_dict), 'The sort is NOT right'


@pytest.mark.okz
def test_ret_dict_info() -> None:
    some_dict = {'a': 'A', 'b': 'B', 'c': 'C'}
    ret = _ret_dict_info(some_dict, 'the name', '-prefix-')
    print(ret)
    assert 'the name' in ret
    assert ': [dict] (#=3)' in ret
    assert '-prefix-' in ret
    assert '-prefix- the name' in ret
    assert 'the name       : [dict] (#=3)' in ret
    assert '-prefix- the name       : [dict] (#=3)' in ret


@pytest.mark.okz
def test_ret_before_or_after() -> None:

    with pytest.raises(AssertionError) as excinfo:
        ret_before_or_after(None)
    assert str(excinfo.value) == 'No param "func_name"'
    with pytest.raises(AssertionError) as excinfo:
        ret_before_or_after('')
    assert str(excinfo.value) == 'No param "func_name"'
    # with pytest.raises(AssertionError) as excinfo:
    #     ret_before_or_after('before-or-after')
    # assert str(excinfo.value) == 'No _ char found in "func_name". (Expects _)'

    assert 'Before' == ret_before_or_after('before_')
    assert 'Before' == ret_before_or_after('beforehand')
    assert 'Before' == ret_before_or_after('before_some_text')
    assert 'Before' == ret_before_or_after('beforesometext')
    assert 'Before' == ret_before_or_after('some_text_before')
    assert 'Before' == ret_before_or_after('sometextbefore')
    assert 'After' == ret_before_or_after('after')
    assert 'After' == ret_before_or_after('after_some_text')
    assert 'After' == ret_before_or_after('some_text_after')
    assert 'After' == ret_before_or_after('hereafterlife')


def _clear_caplog(caplog) -> None:
    """
    Function used in tests to clear the caplog log while running the test.
    """
    # Clear the captured log records and formatted log output
    caplog.clear()

    # Assert that the log is cleared
    assert len(caplog.records) == 0
    assert caplog.text == ''


# def _is_increasing_sequence(lst) -> None:
#     for i in range(len(lst) - 1):
#         if lst[i] >= lst[i + 1]:
#             return False
#     return True


def remove_ansi_escape_sequences(text: str):
    # print('------------> remove_ansi_escape_sequences from:')
    # print(text) # There might be ANSI escape sequences in the text
    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
    ret = ansi_escape.sub('', text)
    # print(ret) # No more ANSI escape sequences in the text
    return ret


def assert_logged(
    caplog, level, expected: List, in_sequence: bool = False
) -> None:   # TODO in_sequence
    assert isinstance(expected, list)
    assert len(expected) > 0, 'No expected messages passed to assert_logged'
    assert bool(expected), 'No expected messages passed to assert_logged'

    print(f'#### expects {len(expected)} message(s):')
    print('\n'.join(expected))

    # Access the captured log records based on log level
    filtered_records = [record for record in caplog.records if record.levelno == level]
    # Get the stripped messages
    # stripped_messages = strip_ansi_from_records(filtered_records)
    messages_found = []
    lines: List[int] = []
    rest = expected.copy()

    for record in filtered_records:
        assert isinstance(record, logging.LogRecord)
        # Inspect and assert the log records as needed
        for msg in rest:
            assert record.levelno == level, f'record.levelname = {record.levelname}'
            assert isinstance(record.message, str), f'record.message = {record.message}'
            stripped_message = remove_ansi_escape_sequences(record.message)
            print('cp: ' + record.message + COL_RESET)
            # print(COL_RESET)
            print('st: ' + stripped_message)
            # if msg in record.message:
            if msg in stripped_message:
                print('\nSeeked&found: ' + msg + '\n')
                messages_found += [msg]
                lines += [record.lineno]
                break
            else:
                print("\n#### Didn't find: \n" + msg + '\n####')

            print(f'#### found {len(lines)} message lines')
            for line in lines:
                print(line)
            # print(lines)
            #
        #
        print('#### rest messages before:')
        print(rest)
        print('#### messages_found messages before:')
        print(messages_found)
        rest = [message for message in rest if message not in messages_found]
        print('#### found messages:')
        print(messages_found)
        print('#### rest messages after:')
        print('\n#### '.join(rest))
    #

    # if bool(rest):
    if len(rest) == 0:
        print('#### rest messages (in end):')
        print('\n'.join(rest))
        # assert len(rest) == 0, f"Couldn't find all lines! {len(rest)} lines left: {rest}"
        level_name = logging.getLevelName(level)
        assert not rest, f"Couldn't find wanted {level_name} log messages: {rest}"


@pytest.mark.ok
def test_log_func_name_xxx(caplog) -> None:
    _log_func_name()

    _clear_caplog(caplog)
    _log_func_name()
    expected = [
        '->test_log_func_name_xxx  (prev=0)'
        # "A->test_log_func_name_xxx  (prev=0) << pytest_pyfunc_call (<- by _log_func_name() with caller test_log_func_name_xxx())"
    ]
    assert_logged(caplog, level=INFO, expected=expected)


@pytest.mark.ok
def test_log_func_name_caplog(caplog) -> None:
    assert caplog, '*** No caplog param! ***'
    # Set the logger to capture log messages from
    # Background:
    # Given a function (that log messages):
    #  def: _log_func_name(prev: int = 0)
    #####################################
    lines_expeced = [
        '#' * 75,
        f'  {_ret_func_name()}  '.center(75, '#'),
        '#' * 75,
    ]

    assert_logged(caplog, level=INFO, expected=lines_expeced, in_sequence=True)

    _clear_caplog(caplog)
    # When called with a non-default fillchar
    plus = '+'
    # Then I will see that the log uses that fillchar instead of the default
    _log_func_name()
    # Then I will see that the log uses the wanted fillchar ('+')
    lines_expeced = [f'  {_ret_func_name()}  '.center(75, plus)]
    assert_logged(caplog, level=INFO, expected=lines_expeced)


@pytest.mark.okz
def test_log_func_name_logging() -> None:
    assert _ret_func_name() == 'test_log_func_name_logging'
    fillchar = '#'

    with patch('logging.info') as mock_info:
        _log_func_name()
        # Assert that the mock_info was called 3 times with the expected arguments
        # mock_info.assert_has_calls([
        mock_info.assert_has_calls(
            [
                call('\t%s', fillchar * 75),
                call('\t%s', '  test_log_func_name_logging  '.center(75, fillchar)),
                call('\t%s', fillchar * 75),
            ]
        )
    #


@pytest.mark.okz
def test_log_headline() -> None:
    assert _ret_func_name() == 'test_log_headline'
    fillchar = '#'

    with patch('logging.info') as mock_info:
        log_headline(msg='Some Headline we want')
        # Assert that the mock_info was called 3 times with the expected arguments
        # mock_info.assert_has_calls([
        mock_info.assert_has_calls(
            [
                call('\t%s', fillchar * 75),
                call('\t%s', '  Some Headline we want  '.center(75, fillchar)),
                call('\t%s', fillchar * 75),
            ]
        )
    #


# @pytest.fixture
# def feature_mock(mocker) -> None:
#     # Create a mock object for the ExternalService class
#     mock_service = mocker.Mock()
#     # Set the return value for the get_data() method
#     mock_service.get_data.return_value = 'Mocked data'
#     return mock_service


# @mock.patch('tests.common.log_glue_incl.log_msg_start')
# @mock.patch('tests.common.log_glue_incl.log_msg')
# @mock.patch('tests.common.log_glue_incl.log_msg_end')
