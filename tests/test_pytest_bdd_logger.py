import logging
import traceback  # for debuggin my test finding out when warning was logged
import warnings  # for debuggin my test finding out when warning was logged
from typing import List
from unittest import mock

# from logging import DEBUG, INFO, WARN, LogRecord
# from typing import Callable, Generator, List
# from unittest import mock
from unittest.mock import call, patch

import pytest
from pytest_bdd.parser import Feature  # , Scenario, ScenarioTemplate, Step

from tests.common.log_helper import (  # log_msg_end,; TEST_CONTEXT,; GLUE_LOGGER,; KEY_DBG_LOG_GLUE,; KEY_DBG_LOGGING,; KEY_LOGGER,
    COL_CONTEXT,
    KEY_LOG_GLUE,
    TEST_CONTEXT,
    LogHelper,
)
from tests.common.pytest_bdd_logger import PytestBddLogger
from tests.common.pytest_bdd_logger_interface import PytestBddLoggerInterface
from tests.common.pytest_bdd_tracer import PytestBddTracer

# from tests.common.log_glue_incl import xret_sorted  # tested
# from tests.common.log_glue_incl import xlog_msg, xlog_msg_start

# from pytest_mock import MockerFixture


# Configure the logger you want to capture log messages from
logger = logging.getLogger(KEY_LOG_GLUE)

bdd_logger = PytestBddLogger(False)


"""
    Many tests here use caplog (CAPtured LOGged messages)
    pytest caplog is a built-in fixture provided by the pytest
    testing framework in Python.
    It is used for capturing and inspecting log messages during test execution.
    The caplog fixture allows you to access log records generated by your code
    under test, making it easier to assert and analyze log output in your tests.

    When you use the caplog fixture in your test function or test method,
    pytest captures all log messages emitted by the code being tested.
    You can then access these log records through the caplog.records attribute.
"""


def _the_caller0() -> str:
    return LogHelper.ret_func_name()


def _the_caller(prev: int = 0) -> str:
    return LogHelper.ret_func_name(prev)


def _func1(prev: int = 1) -> str:
    return _the_caller(prev)


def _func2(prev: int = 2) -> str:
    return _func1(prev)


def _func3(prev: int = 3) -> str:
    # _func3: _func2 -> _func1 -> _the_caller
    return _func2(prev)


@pytest.mark.ok
def test_just_show_test_context() -> None:
    LogHelper.log_func_name()
    logging.info('==> test_just_show_test_context')
    logging.info('%s TEST_CONTEXT: %s', COL_CONTEXT, TEST_CONTEXT)
    LogHelper.log_dict_now(TEST_CONTEXT, 'TEST_CONTEXT-0')
    logging.info('<== test_just_show_test_context')


def _clear_caplog(caplog) -> None:
    """
    Function used in test to clear the caplog log while running the test.
    """
    # Clear the captured log records and formatted log output
    caplog.clear()

    # Assert that the log is cleared
    assert len(caplog.records) == 0
    assert caplog.text == ''


def _is_increasing_sequence(lst) -> None:
    for i in range(len(lst) - 1):
        if lst[i] >= lst[i + 1]:
            return False
    return True


def _assert_messages(caplog, level, messages: List, in_sequence: bool = False) -> None:
    print('#### messages:')
    for msg in messages:
        print(msg)
    # Access the captured log records based on log level
    filtered_records = [record for record in caplog.records if record.levelno == level]
    messages_found = []
    lines: List[int] = []
    rest = messages.copy()

    for record in filtered_records:
        assert isinstance(record, logging.LogRecord)
        # Inspect and assert the log records as needed
        for msg in rest:
            assert record.levelno == level, f'record.levelname = {record.levelname}'
            if msg in record.message:
                print('\nSeeked&found: ' + msg)
                messages_found += [msg]
                lines += [record.lineno]
                # print("#### found messages:")
                # print(messages_found)
                break
            else:
                print("\n Didn't find: " + msg)

            print('#### found message lines:')
            print(lines)
            #
        #
        print('#### rest messages before:')
        print(rest)
        print('#### messages_found messages before:')
        print(messages_found)
        rest = [message for message in rest if message not in messages_found]
        # print("#### found messages:")
        # print(messages_found)
        print('#### rest messages after:')
        print(rest)
    #

    # print("#### rest messages (in end):")
    print(rest)
    level_name = logging.getLevelName(level)
    assert len(rest) == 0, f"Couldn't find wanted {level_name} log messages: {rest}"
    assert not rest, f"Couldn't find wanted {level_name} log messages: {rest}"


@pytest.mark.skip
def test_log_msg_start() -> None:
    LogHelper.log_func_name()

    with patch('logging.info') as mock_info:
        fillchar = 'Â¤'
        # xlog_msg_start()
        # Assert that the mock_info was called 3 times with the expected arguments
        # mock_info.assert_has_calls([
        mock_info.assert_has_calls(
            [
                # call('%s', fillchar * 75),
                call('%s', '  test_log_msg_start  '.center(75, fillchar)),
                # call('%s', fillchar * 75),
            ]
        )


# @pytest.fixture
# def feature_mock(mocker: Callable[..., Generator[MockerFixture, None, None]]):
#     # Create a mock object for the ExternalService class
#     mock_service = mocker.Mock()
#     # Set the return value for the get_data() method
#     mock_service.get_data.return_value = 'Mocked data'
#     return mock_service


@pytest.mark.wipz
def test_before_feature() -> None:
    LogHelper.log_func_name()

    # Given:
    bdd_logger = PytestBddLogger()

    # Given a "valid feature" (in our test context)
    feature = Feature(None, '', '', 'Feature_name', set(), None, 1, '')

    # #### Assert functions called
    # When I call
    logging.info('When I call: before_feature(None, feature)')
    module = 'tests.common.pytest_bdd_tracer'
    with mock.patch.multiple(
        PytestBddTracer,
        log_hook=mock.DEFAULT,
    ) as bdd_tracer_mock, mock.patch.multiple(
        PytestBddLoggerInterface,
        log_dict=mock.DEFAULT,
    ) as bdd_logger_interface_mock:
        bdd_logger.before_feature(None, feature)

        # Then assert that the mocked functions were called
        logging.info('Then assert that the mocked functions were called')
        # mock_log_func_name.assert_called_once()
        # mock_log_hook.assert_called_once()
        bdd_tracer_mock['log_hook'].assert_called_once()
        bdd_logger_interface_mock['log_dict'].assert_called_once()

    # assert False, 'Not passing test_before_feature!'

    # Enable warnings to be displayed as exceptions
    warnings.filterwarnings('error')

    try:
        with patch('logging.info') as mock_info:
            bdd_logger.before_feature(None, feature)

            # Accessing the mock_calls attribute to see the logged messages
            logging.info('These messsages were logged:')
            for call in mock_info.mock_calls:
                # print(call)
                logging.info(call)

            # # Assert that the mock_info was called with the expected arguments
            # logging.info('Assert we got expected calls')
            # mock_info.assert_called_with(mock.ANY, 'H: log_hook()', mock.ANY)
            # # mock_info.assert_called_with(mock.ANY, '*** before_feature ***', mock.ANY)
            # mock_info.assert_has_calls(
            #     [
            #         # call("*** before_feature ***"),
            #         call("-> ret_func_name(prev=0)"),
            #         # call("->log_func_name(prev=0) (<- by log_func_name() with caller test_before_feature())"),
            #     ]
            # )

    except Warning as w:
        # Print the traceback to find the source of the warning
        traceback.print_tb(w.__traceback__)


@pytest.mark.wipz
def test_before_feature_do_update_context() -> None:
    LogHelper.log_func_name()
    bdd_logger = PytestBddLogger()
    # assert bdd_logger.get_test_context() == TEST_CONTEXT

    # Given a "valid feature" (in our test context)
    feature = Feature(None, '', '', 'Feature_name', set(), None, 1, '')

    # #### Assert functions called
    module = 'tests.common.log_helper'
    module = 'tests.common.pytest_bdd_logger'
    with (
        # patch(module + '.log_func_name') as mock_log_func_name, #TODO Moved to LogHelper
        # patch(module + '.log_feature') as mock_log_feature,
        patch(module + '.log_feature') as mock_log_feature,
    ):
        assert isinstance(bdd_logger, PytestBddLogger)
        # When I call
        logging.info('When I call: before_feature(None, feature)')
        bdd_logger.before_feature(None, feature)

        # Then assert that the mocked functions were called
        logging.info('Then assert that the mocked functions were called')
        # mock_log_func_name.assert_called_once()
        mock_log_feature.assert_called_once()
