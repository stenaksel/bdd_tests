import logging
from typing import List

#from logging import DEBUG, INFO, WARN, LogRecord
#from typing import Callable, Generator, List
#from unittest import mock
from unittest.mock import call, patch

import pytest
from pytest_bdd.parser import Feature  # , Scenario, ScenarioTemplate, Step

from tests.common.log_glue_incl import log_func_name  # tested
from tests.common.log_glue_incl import ret_sorted  # tested
from tests.common.log_glue_incl import KEY_LOG_GLUE, TEST_CONTEXT, old_log_msg, xlog_msg_start
from tests.common.pytest_bdd_logger import PytestBddLogger
from tests.common.pytest_bdd_logger_interface import xret_func_name

#from pytest_mock import MockerFixture


# Configure the logger you want to capture log messages from
logger = logging.getLogger(KEY_LOG_GLUE)

bdd_logger = PytestBddLogger()


"""
    Many tests here use caplog (CAPtured LOGged messages)
    pytest caplog is a built-in fixture provided by the pytest
    testing framework in Python.
    It is used for capturing and inspecting log messages during test execution.
    The caplog fixture allows you to access log records generated by your code
    under test, making it easier to assert and analyze log output in your tests.

    When you use the caplog fixture in your test function or test method,
    pytest captures all log messages emitted by the code being tested.
    You can then access these log records through the caplog.records attribute.
"""


def _the_caller0() -> str:
    return xret_func_name()


def _the_caller(prev: int = 0) -> str:
    return xret_func_name(prev)


def _func1(prev: int = 1) -> str:
    return _the_caller(prev)


def _func2(prev: int = 2) -> str:
    return _func1(prev)


def _func3(prev: int = 3) -> str:
    # _func3: _func2 -> _func1 -> _the_caller
    return _func2(prev)


@pytest.mark.ok
def test_just_show_test_context() -> None:
    logging.info('==> test_just_show_test_context')
    logging.info('TEST_CONTEXT: ')
    logging.info(TEST_CONTEXT)
    bdd_logger.log_dict_now(TEST_CONTEXT, 'TEST_CONTEXT0')
    logging.info('<== test_just_show_test_context')


def _clear_caplog(caplog) -> None:
    """
    Function used in test to clear the caplog log while running the test.
    """
    # Clear the captured log records and formatted log output
    caplog.clear()

    # Assert that the log is cleared
    assert len(caplog.records) == 0
    assert caplog.text == ''


def _is_increasing_sequence(lst) -> None:
    for i in range(len(lst) - 1):
        if lst[i] >= lst[i + 1]:
            return False
    return True


def _assert_messages(caplog, level, messages: List, in_sequence: bool = False) -> None:
    print('#### messages:')
    for msg in messages:
        print(msg)
    # Access the captured log records based on log level
    filtered_records = [record for record in caplog.records if record.levelno == level]
    messages_found = []
    lines: List[int] = []
    rest = messages.copy()

    for record in filtered_records:
        assert isinstance(record, logging.LogRecord)
        # Inspect and assert the log records as needed
        for msg in rest:
            assert record.levelno == level, f'record.levelname = {record.levelname}'
            if msg in record.message:
                print('\nSeeked&found: ' + msg)
                messages_found += [msg]
                lines += [record.lineno]
                # print("#### found messages:")
                # print(messages_found)
                break
            else:
                print("\n Didn't find: " + msg)

            print('#### found message lines:')
            print(lines)
            #
        #
        print('#### rest messages before:')
        print(rest)
        print('#### messages_found messages before:')
        print(messages_found)
        rest = [message for message in rest if message not in messages_found]
        # print("#### found messages:")
        # print(messages_found)
        print('#### rest messages after:')
        print(rest)
    #

    # print("#### rest messages (in end):")
    print(rest)
    level_name = logging.getLevelName(level)
    assert len(rest) == 0, f"Couldn't find wanted {level_name} log messages: {rest}"
    assert not rest, f"Couldn't find wanted {level_name} log messages: {rest}"


@pytest.mark.skip
def test_log_msg_start() -> None:

    with patch('logging.info') as mock_info:
        fillchar = 'Â¤'
        xlog_msg_start()
        # Assert that the mock_info was called 3 times with the expected arguments
        # mock_info.assert_has_calls([
        mock_info.assert_has_calls(
            [
                # call('%s', fillchar * 75),
                call('%s', '  test_log_msg_start  '.center(75, fillchar)),
                # call('%s', fillchar * 75),
            ]
        )


# @pytest.fixture
# def feature_mock(mocker: Callable[..., Generator[MockerFixture, None, None]]):
#     # Create a mock object for the ExternalService class
#     mock_service = mocker.Mock()
#     # Set the return value for the get_data() method
#     mock_service.get_data.return_value = 'Mocked data'
#     return mock_service


# @mock.patch('tests.common.log_glue_incl.log_msg_start')
# @mock.patch('tests.common.log_glue_incl.log_msg')
# @mock.patch('tests.common.log_glue_incl.log_feature')
# @mock.patch('tests.common.log_glue_incl.log_msg_end')


# @pytest.mark.ok
@pytest.mark.wip
def test_before_feature_params() -> None:
    #Given:
    bdd_logger = PytestBddLogger()
    # assert isinstance(bdd_logger, PytestBddLogger)

    #### No feature:
    # When before_feature() is called without feature param
    _request = None
    feature = None
    with pytest.raises(AssertionError) as assert_msg:
        bdd_logger.before_feature(_request, feature)
    assert 'No feature param!' in str(assert_msg.value), str(assert_msg.value)

    #### Empty feature name
    # When before_feature() is called with a feature param with an empty name
    name = ''
    feature = Feature(None, '', '', name, set(), None, 1, '')
    assert feature.name == ''
    with pytest.raises(AssertionError) as assert_msg:
        bdd_logger.before_feature(None, feature)
        assert str(assert_msg.value) == 'Feature unknown!'
    # ####


@pytest.mark.ok
def test_before_feature() -> None:
    bdd_logger = PytestBddLogger()

    # Given a "valid feature" (in our test context)
    feature = Feature(None, '', '', 'Feature_name', set(), None, 1, '')

    # #### Assert functions called
    module = 'tests.common.bdd_logger'
    with patch(f'{module}.log_msg_start') as mock_log_msg_start, patch(
        f'{module}.log_feature'
    ) as mock_log_feature, patch(f'{module}.log_msg_end') as mock_log_msg_end:
        # When I call
        logging.info('When I call: before_feature(None, feature)')

        bdd_logger.before_feature(None, feature)

        # Then assert that the mocked functions were called
        logging.info('Then assert that the mocked functions were called')
        mock_log_msg_start.assert_called_once()
        mock_log_feature.assert_called_once()
        mock_log_msg_end.assert_called_once()


@pytest.mark.todo
def test_before_feature_do_update_context() -> None:
    bdd_logger = PytestBddLogger()
    assert bdd_logger.get_test_context() == TEST_CONTEXT

    # Given a "valid feature" (in our test context)
    feature = Feature(None, '', '', 'Feature_name', set(), None, 1, '')

    # #### Assert functions called
    module = 'tests.common.bdd_logger'
    with patch(module + '.log_msg_start') as mock_log_msg_start, patch(
        module + '.log_feature'
    ) as mock_log_feature, patch(module + '.log_msg_end') as mock_log_msg_end:
        # When I call
        logging.info('When I call: before_feature(None, feature)')
        assert isinstance(bdd_logger, PytestBddLogger)

        bdd_logger.before_feature(None, feature)

        # Then assert that the mocked functions were called
        logging.info('Then assert that the mocked functions were called')
        mock_log_msg_start.assert_called_once()
        mock_log_feature.assert_called_once()
        mock_log_msg_end.assert_called_once()


@pytest.mark.ok
def test_before_feature_2() -> None:
    # Given a feature
    feature = Feature(None, '', '', 'Feature_name', set(), None, 1, '')
    logging.info('-> Created feature with name "%s"', feature.name)

    # When I call before_feature(None, feature)
    # #### Assert functions called
    module = 'tests.common.log_glue_incl'   # tests.common.log_glue_incl
    with (
        patch(f'{module}.log_msg_start') as mock_log_msg_start,
        patch(f'{module}.log_feature') as mock_log_feature,
        patch(f'{module}.log_msg_end') as mock_log_msg_end,
    ):
        print('When I call: before_feature(None, feature)')
        logging.info('When I call: before_feature(None, feature)')
        bdd_logger.before_feature(None, feature)

        # Then assert that the mocked functions were called
        print('Then assert that the mocked functions were called')
        logging.info('Then assert that the mocked functions were called')
        mock_log_msg_start.assert_called_once()
        # mock_log_feature.assert_called_once()
        mock_log_msg_end.assert_called_once()
        # And expect sequence of calls:
        logging.info('And expect sequence of calls:')
        expected_calls = [
            # call.log_msg('Found feature: '),  #
            # call.log_msg('Found feature: '),  #
            call.log_msg_start(),  #
            # call.log_feature(feature),  #
            # call.log_feature(),  #
            call.log_msg_end(),  #
        ]
        # expected_calls:
        for func in expected_calls:
            logging.info('  %s', func)
        # mock_log_msg_end.assert_has_calls(expected_calls)


@pytest.mark.skip   # TODO Not working yet
def test_log_msg() -> None:
    with patch('logging.info') as mock_info:
        old_log_msg('Testing')

        # Assert that the mock_info was called times with the expected arguments
        mock_info.assert_has_calls(
            [
                call('%s', '#' * 75),
                call('%s', '  test_log_func_name  '.center(75, '#')),
                call('%s', '#' * 75),
            ]
        )
