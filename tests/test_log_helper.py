"""
Many tests here use caplog (CAPtured LOGged messages)
pytest caplog is a built-in fixture provided by the pytest
testing framework in Python.
It is used for capturing and inspecting log messages during test execution.
The caplog fixture allows you to access log records generated by your code
under test, making it easier to assert and analyze log output in your tests.

When you use the caplog fixture in your test function or test method,
pytest captures all log messages emitted by the code being tested.
You can then access these log records through the caplog.records attribute.
"""
import logging
import re
from contextlib import contextmanager

# from logging import DEBUG, INFO, WARN, LogRecord
from logging import INFO
from typing import Any, List
from unittest.mock import call, patch

import pytest
from common.log_helper import COL_CONTEXT, COL_INFO, COL_MSG, COL_RESET, TEST_CONTEXT, LogHelper

# from common.pytest_bdd_tracer import PytestBddTracer
from common.pytest_bdd_logger import PytestBddLogger
from pytest_bdd.parser import Feature  # , Scenario, ScenarioTemplate, Step

# (
#     # ret_keys,
#     log_dict_now,  # TODO Make test
#     log_func_name,
#     log_headline,
#     # ret_classname,
#     ret_dict_info,
#     ret_func_name,
#     log_func_call,
#     log_func_name,
# )


@contextmanager
def not_raises(ExpectedException):
    try:
        yield

    except ExpectedException as error:
        raise AssertionError(f'Raised exception {error} when it should not!')

    except Exception as error:
        raise AssertionError(f'An unexpected exception {error} raised.')


def _the_caller(prev: int = 0) -> str:
    return LogHelper.ret_func_name(prev)


def _func1(prev: int = 1) -> str:
    return _the_caller(prev)


def _func2(prev: int = 2) -> str:
    return _func1(prev)


def _func3(prev: int = 3) -> str:
    # _func3: _func2 -> _func1 -> _the_caller
    return _func2(prev)


@pytest.mark.ok
def test_just_show_test_context() -> None:
    logging.info('==> test_just_show_test_context')
    logging.info('TEST_CONTEXT: ')
    logging.info(TEST_CONTEXT)
    logging.info('<== test_just_show_test_context')


@pytest.mark.ok
def test_ret_classname() -> None:
    bdd_logger = PytestBddLogger()
    assert bdd_logger.ret_classname() == 'PytestBddLogger'
    # bdd_logger = PytestBddTracer()
    # assert bdd_logger.ret_classname() == 'PytestBddTracer'


@pytest.mark.ok
def test_log_func_name() -> None:
    # logging.info('==> test_log_func_name')

    assert LogHelper.ret_func_name() == 'test_log_func_name'

    # The different _func have a default "prev" param
    # that will be passed on to _the_caller and should return themself
    # _the_caller is the only function calling LogHelper.log_func_name function.

    assert _the_caller() == '_the_caller'  # _the_caller of LogHelper.log_func_name
    assert _func1() == '_func1'  # will only call _the_caller
    assert _func2() == '_func2'  # will only call _func1
    assert _func3() == '_func3'  # will only call _func2
    assert _func3(3) == '_func3'  # will only call _func2(prev=3)
    assert _func3(2) == '_func2'  # will only call _func2(prev=2)
    assert _func3(1) == '_func1'  # will only call _func2(prev=1)
    assert _func3(0) == '_the_caller'  # will only call _func2(prev=0)

    # logging.info('<== test__log_func_name')


@pytest.mark.ok
def test_ret_sorted() -> None:
    some_dict = {'c': 'C', 'a': 'A', 'b': 'B'}
    correct_dict = {'a': 'A', 'b': 'B', 'c': 'C'}
    some_keys = LogHelper.ret_keys(some_dict)
    print(some_dict)
    print(some_keys)
    sorted_dict = LogHelper.ret_sorted(some_dict)
    sorted_keys = LogHelper.ret_keys(sorted_dict)
    print(some_dict)
    print(some_keys)
    print(sorted_dict)
    print(sorted_keys)
    assert sorted_dict == correct_dict, 'The sort is NOT right'
    assert LogHelper.ret_keys(sorted_dict) == LogHelper.ret_keys(
        correct_dict
    ), 'The sort is NOT right'


@pytest.mark.ok
def test_assert_object() -> None:
    par_none = None
    par_string_long = 'a legal string'
    empty_string = ''
    none_obj = None
    par_ok = Feature([], '', '', 'name', set(), None, 1, '')

    # inner_func ->
    def _some_assert_object_caller(p1: Any, p2: Any) -> None:
        logging.info('==> _some_assert_object_caller')
        LogHelper.log_func_call()
        logging.info('\tLogHelper.assert_object(p1):%s', p1)
        LogHelper.assert_object(p1)
        logging.info('\tLogHelper.assert_object(p2):%s', p2)
        LogHelper.assert_object(p2)

    # <- inner_func

    with pytest.raises(AssertionError) as info:
        # LogHelper.assert_string(none_param)
        _some_assert_object_caller(par_none, par_ok)
        assert (
            "The object param 'p1' in function _some_assert_object_caller was no object"
            in info.value
        )
        assert False, '1Stopping here...'

    with pytest.raises(AssertionError) as info:
        # LogHelper.assert_string(none_param)
        _some_assert_object_caller(par_ok, par_none)
        assert (
            "The object param 'p2' in function _some_assert_object_caller was no object"
            in info.value
        )
        assert False, '1Stopping here...'


@pytest.mark.ok
def test_assert_string() -> None:
    # inner_func ->
    def _some_assert_value_caller(
        p1: str, p2: str, min_length1: int | None = None, min_length2: int | None = None
    ) -> None:
        logging.info('==> _some_assert_value_caller')
        LogHelper.log_func_call()
        if min_length1 is None and min_length2 is None:
            logging.info('\tLogHelper.assert_string(p1):%s', p1)
            LogHelper.assert_string(p1)
            logging.info('\tLogHelper.assert_string(p2):%s', p2)
            LogHelper.assert_string(p2)
        elif min_length1 is not None and min_length2 is not None:
            logging.info('\tLogHelper.assert_string(p1, min_length1=%s):%s', min_length1, p1)
            LogHelper.assert_string(p1, min_length1)
            logging.info('\tLogHelper.assert_string(p2, min_length2=%s):%s', min_length2, p2)
            LogHelper.assert_string(p2, min_length2)
        elif min_length1 is not None:
            assert min_length2 is None
            logging.info('\tLogHelper.assert_string(p1, min_length1)')
            LogHelper.assert_string(p1, min_length1)
            logging.info('\tLogHelper.assert_string(p2)')
            LogHelper.assert_string(p2)
        elif min_length2 is not None:
            assert min_length1 is None
            logging.info('\tLogHelper.assert_string(p1)')
            LogHelper.assert_string(p1)
            logging.info('\tLogHelper.assert_string(p2, min_length2)')
            LogHelper.assert_string(p2, min_length2)

    # <- inner_func

    par_none = None
    par_string_long = 'a legal string'
    empty_string = ''
    feature = Feature(None, '', '', 'name', set(), None, 1, '')

    with pytest.raises(AssertionError) as info:
        _some_assert_value_caller(feature, par_string_long)
        logging.info('str(info.value): %s', str(info.value))
        logging.info('info.value: %s', info.value)
        assert (
            "The string param 'p1' in function _some_assert_value_caller was no string"
            in info.value
        )

    with pytest.raises(AssertionError) as info:
        # LogHelper.assert_string(none_param)
        _some_assert_value_caller(par_none, par_string_long)
        assert (
            "The string param 'p1' in function _some_assert_value_caller was no string"
            in info.value
        )
        # assert False, '1Stopping here...'

    with pytest.raises(AssertionError) as info:
        _some_assert_value_caller(None, par_string_long)
    # assert "The string param 'value_param' was not supplied a string " in str(info.value)
    assert "The string param 'p1' in function _some_assert_value_caller was no string" in str(
        info.value
    )
    # assert False, '2Stopping here...'

    with pytest.raises(AssertionError) as info:
        _some_assert_value_caller(par_string_long, par_none)
    # assert "The string param 'value_param' was not supplied a string " in str(info.value)
    assert "The string param 'p2' in function _some_assert_value_caller was no string" in str(
        info.value
    )
    # assert "The string param 'p2' was empty!" in str(info.value)
    # assert False, '3Stopping here...'

    with pytest.raises(AssertionError) as info:
        _some_assert_value_caller(empty_string, 'Param2')
    assert "The string param 'p1' in function _some_assert_value_caller was too short" in str(
        info.value
    )

    with pytest.raises(AssertionError) as info:
        _some_assert_value_caller('12345', 'Param2', 6)
    assert "The string param 'p1' in function _some_assert_value_caller was too short" in str(
        info.value
    )
    # Just showing the full assert output:
    assert (
        str(info.value)
        == "The string param 'p1' in function _some_assert_value_caller was too short: '12345' (reports assert_string())!"
    )


@pytest.mark.ok
def test_assert_object_have_name() -> None:
    LogHelper.log_func_name()

    # Given:
    bdd_logger = PytestBddLogger()
    assert not hasattr(
        bdd_logger, 'name'
    ), "Wrong type of object for this test! (Shouldn't have a name attribute)"

    #### No named_obj / is None:
    # When assert_object_have_name() is called without named_obj param
    named_obj = None
    expect = 'No named_obj param!'
    with pytest.raises(AssertionError) as assert_msg:
        LogHelper.assert_object_have_name(named_obj)
    assert expect in str(assert_msg.value), f'Expected: "{expect}", Actual: "{assert_msg.value}"'

    #### Named object without a name attribute
    expect = "Couldn't find a name!"
    with pytest.raises(AssertionError) as assert_msg:
        LogHelper.assert_object_have_name(bdd_logger)
    assert expect in str(assert_msg.value), f'Expected: "{expect}", Actual: "{assert_msg.value}"'

    #### Dict WITH a name key:
    assert (
        TEST_CONTEXT.get('name', None) is not None
    ), "Wrong type of dict for this test! (Shouldn't have a name key)"
    with not_raises(AssertionError):
        LogHelper.assert_object_have_name(TEST_CONTEXT)

    #### Dict without name key:
    expect = "Couldn't find a name! In dict : {'some key': 'some value', 'but': 'no name key!'}"
    # expect = "Couldn't find a name!"
    a_dict = {'some key': 'some value', 'but': 'no name key!'}
    with pytest.raises(AssertionError) as assert_msg:
        LogHelper.assert_object_have_name(a_dict)
    assert expect in str(assert_msg.value), f'Expected: "{expect}", Actual: "{assert_msg.value}"'

    #### Empty feature name:
    # When before_feature() is called with a feature param with an empty name
    expect = 'Feature name should be longer! Was just: "xx"'
    name: str = 'xx'
    feature = Feature(None, '', '', name, set(), None, 1, '')

    assert feature.name == 'xx', f'Expected: "the name", Actual: "{feature.name}"'
    with pytest.raises(AssertionError) as assert_msg:
        LogHelper.assert_object_have_name(feature)
    assert expect in str(assert_msg.value), f'Expected: "{expect}", Actual: "{assert_msg.value}"'
    # ####


@pytest.mark.ok
def test_ret_dict_info() -> None:
    some_dict = {'a': 'A', 'b': 'B', 'c': 'C'}
    ret = LogHelper.ret_dict_info(some_dict, 'the name', '-prefix-')
    print(ret)
    assert 'the name' in ret
    assert ': [dict] (#=3)' in ret
    assert '-prefix-' in ret
    assert '-prefix- the name' in ret
    assert 'the name       : [dict] (#=3)' in ret
    assert '-prefix- the name       : [dict] (#=3)' in ret
    # TODO assert False, 'Implementation not finished yet'


@pytest.mark.ok
def test_ret_before_or_after() -> None:
    with pytest.raises(AssertionError) as excinfo:
        LogHelper.ret_before_or_after(None)
    assert str(excinfo.value) == 'No param "func_name"'
    with pytest.raises(AssertionError) as excinfo:
        LogHelper.ret_before_or_after('')
    assert str(excinfo.value) == 'No param "func_name"'
    # with pytest.raises(AssertionError) as excinfo:
    #     LogHelper.ret_before_or_after('before-or-after')
    # assert str(excinfo.value) == 'No _ char found in "func_name". (Expects _)'

    assert 'Before' == LogHelper.ret_before_or_after('before_')
    assert 'Before' == LogHelper.ret_before_or_after('beforehand')
    assert 'Before' == LogHelper.ret_before_or_after('before_some_text')
    assert 'Before' == LogHelper.ret_before_or_after('beforesometext')
    assert 'Before' == LogHelper.ret_before_or_after('some_text_before')
    assert 'Before' == LogHelper.ret_before_or_after('sometextbefore')
    assert 'After' == LogHelper.ret_before_or_after('after')
    assert 'After' == LogHelper.ret_before_or_after('after_some_text')
    assert 'After' == LogHelper.ret_before_or_after('some_text_after')
    assert 'After' == LogHelper.ret_before_or_after('hereafterlife')


def _clear_caplog(caplog) -> None:
    """
    Function used in tests to clear the caplog log while running the test.
    """
    # Clear the captured log records and formatted log output
    caplog.clear()

    # Assert that the log is cleared
    assert len(caplog.records) == 0
    assert caplog.text == ''


# def _is_increasing_sequence(lst) -> None:
#     for i in range(len(lst) - 1):
#         if lst[i] >= lst[i + 1]:
#             return False
#     return True


def remove_ansi_escape_sequences(text: str):
    # print('------------> remove_ansi_escape_sequences from:')
    # print(text) # There might be ANSI escape sequences in the text
    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
    ret = ansi_escape.sub('', text)
    # print(ret) # No more ANSI escape sequences in the text
    return ret


def assert_logged(
    caplog, level, expected: List, _in_sequence: bool = False
) -> None:  # TODO in_sequence
    assert isinstance(expected, list)
    assert len(expected) > 0, 'No expected messages passed to assert_logged'
    assert bool(expected), 'No expected messages passed to assert_logged'

    print(f'#### expects {len(expected)} message(s):')
    print('\n'.join(expected))

    # Access the captured log records based on log level
    filtered_records = [record for record in caplog.records if record.levelno == level]
    # Get the stripped messages
    # stripped_messages = strip_ansi_from_records(filtered_records)
    messages_found = []
    lines: List[int] = []
    rest = expected.copy()

    for record in filtered_records:
        assert isinstance(record, logging.LogRecord)
        # Inspect and assert the log records as needed
        for msg in rest:
            assert record.levelno == level, f'record.levelname = {record.levelname}'
            assert isinstance(record.message, str), f'record.message = {record.message}'
            stripped_message = remove_ansi_escape_sequences(record.message)
            print('cp: ' + record.message + COL_RESET)
            # print(COL_RESET)
            print('st: ' + stripped_message)
            # if msg in record.message:
            if msg in stripped_message:
                print('\nSeeked&found: ' + msg + '\n')
                messages_found += [msg]
                lines += [record.lineno]
                break
            else:
                print("\n#### Didn't find: \n" + msg + '\n####')

            print(f'#### found {len(lines)} message lines')
            for line in lines:
                print(line)
            # print(lines)
            #
        #
        print('#### rest messages before:')
        print(rest)
        print('#### messages_found messages before:')
        print(messages_found)
        rest = [message for message in rest if message not in messages_found]
        print('#### found messages:')
        print(messages_found)
        print('#### rest messages after:')
        print('\n#### '.join(rest))
    #

    # if bool(rest):
    if len(rest) == 0:
        print('#### rest messages (in end):')
        print('\n'.join(rest))
        # assert len(rest) == 0, f"Couldn't find all lines! {len(rest)} lines left: {rest}"
        level_name = logging.getLevelName(level)
        assert not rest, f"Couldn't find wanted {level_name} log messages: {rest}"


@pytest.mark.ok
def test_log_func_name_xxx(caplog) -> None:
    _clear_caplog(caplog)
    LogHelper.log_func_name()
    expected = [
        '->testing_log_func_name_xxx  (prev=0)'
        # "A->test_log_func_name_xxx  (prev=0) << \
        # pytest_pyfunc_call (<- by _log_func_name() with caller test_log_func_name_xxx())"
    ]
    assert_logged(caplog, level=INFO, expected=expected)


@pytest.mark.ok
def test_log_func_name_caplog(caplog) -> None:
    assert caplog, '*** No caplog param! ***'
    # Set the logger to capture log messages from
    # Background:
    # Given a function (that log messages):
    #  def: _log_func_name(prev: int = 0)
    #####################################
    lines_expected = [
        '#' * 75,
        f'  {LogHelper.log_func_name()}  '.center(75, '#'),
        '#' * 75,
    ]

    assert_logged(caplog, level=INFO, expected=lines_expected, _in_sequence=True)

    _clear_caplog(caplog)
    # When called with a non-default fillchar
    plus = '+'
    # Then I will see that the log uses that fillchar instead of the default
    LogHelper.log_func_name()
    # Then I will see that the log uses the wanted fillchar ('+')
    lines_expected = [f'  {LogHelper.log_func_name()}  '.center(75, plus)]
    assert_logged(caplog, level=INFO, expected=lines_expected)


@pytest.mark.ok
def test_quoted_string_from():
    # Given a string param
    param = 'simly a string'
    assert LogHelper.quoted_string_from(param) == f"'{param}'"
    # assert LogHelper._string_from(param) == "'simly a string'"

    # Given a feature param
    name = 'Feature_name'
    feature = Feature(None, '', '', name, set(), None, 1, '')
    assert LogHelper.quoted_string_from(feature) == f"'{name}'"


@pytest.mark.ok
def test_log_func_call():
    def inner_func_for_testing_log_func_call(_p1: str, _p2: str, _p3: int, _feature: Feature):
        # logging.info('==> inner_func_for_testing_log_func_call')
        LogHelper.log_func_call(logging.DEBUG)

    # Given a "valid feature" (in our test context)
    feature = Feature(None, '', '', 'Feature_name', set(), None, 1, '')
    with patch('logging.debug') as mock_debug:
        inner_func_for_testing_log_func_call('val1', 'val2', 3, feature)

    # Assert that the mock_debug was called with the expected arguments
    part2 = f"{COL_INFO}(_p1='val1', _p2='val2', _p3=3, _feature='Feature_name')"
    part3 = (
        f'{COL_CONTEXT}(<- by log_func_call() with caller inner_func_for_testing_log_func_call())'
    )
    expected_call = f'*--* dbg: {COL_MSG}inner_func_for_testing_log_func_call{part2}{part3}'
    print(expected_call)

    # Accessing the mock_calls attribute to see the logged messages
    for a_call in mock_debug.mock_calls:
        print(a_call)
        logging.warning(a_call)

    mock_debug.assert_has_calls(
        [
            call(expected_call),
            # call("expected_call"),
        ]
    )


# @pytest.fixture
# def feature_mock(mocker) -> None:
#     # Create a mock object for the ExternalService class
#     mock_service = mocker.Mock()
#     # Set the return value for the get_data() method
#     mock_service.get_data.return_value = 'Mocked data'
#     return mock_service


# @mock.patch('common.log_glue_incl.log_msg_start')
# @mock.patch('common.log_glue_incl.log_msg')
# @mock.patch('common.log_glue_incl.log_msg_end')


@pytest.mark.ok
def test_log_headline_mock() -> None:
    assert LogHelper.ret_func_name() == 'test_log_headline_mock'
    # With default fillchar
    default_fillchar = '#'
    with patch('logging.info') as mock_info:
        LogHelper.log_headline(LogHelper.ret_func_name())  # Using default fillchar

        # Assert that the mock_info was called 3 times with the expected arguments
        # mock_info.assert_has_calls([
        mock_info.assert_has_calls(
            [
                call('\t%s', default_fillchar * 75),
                call('\t%s', '  test_log_headline_mock  '.center(75, default_fillchar)),
                call('\t%s', default_fillchar * 75),
            ]
        )
    #

    # With custom fillchar
    custom_fillchar = '+'
    with patch('logging.info') as mock_info:
        LogHelper.log_headline(LogHelper.ret_func_name(), fillchar=custom_fillchar)

        # Assert that the mock_info was called 3 times with the expected arguments
        # mock_info.assert_has_calls([
        mock_info.assert_has_calls(
            [
                call('\t%s', custom_fillchar * 75),
                call('\t%s', '  test_log_headline_mock  '.center(75, custom_fillchar)),
                call('\t%s', custom_fillchar * 75),
            ]
        )
    #


@pytest.mark.skip  # TODO Not working yet
def test_log_msg() -> None:
    LogHelper.log_func_name()

    with patch('logging.info') as mock_info:
        # TODO LogHelper.log_msg('Testing')

        # Assert that the mock_info was called times with the expected arguments
        mock_info.assert_has_calls(
            [
                call('%s', '#' * 75),
                call('%s', '  test_log_func_name  '.center(75, '#')),
                call('%s', '#' * 75),
            ]
        )
